# Персистентное дерево отрезков

> Input file name: input.txt

> Output file name: output.txt

> Time limit: 2 s

> Memory limit: 2 MB

В данной задаче необходимо реализовать фильтр Блума.ел на отрезке [li, ri], которые не меньше xi и не превышают yi.

Операции (аргументы строковые величины):
* insert (вставка элемента)
* contains (проверка, правда ли элемент был добавлен ранее)

При запросе contains требуется, если элемент на самом деле был ранее добавлен, возвращать «да» во всех случаях, а если элемент на самом деле добавлен не был, то возвращать «нет» хотя бы в 99% случаев.

### Формат входного файла

В первой строке файла написано одно целое число N — количество запросов к фильтру (10 000 ≤ N ≤ 1 000 000). Далее, каждая из N последующих строк состоит из двух элементов: тип запроса и значение запроса, разделенные пробелом. Тип запроса может принимать значение 0 или 1. Если тип равен 1, то значение запроса — объект, которые необходимо добавить в фильтр, а если тип равен 0 — объект, для которого необходимо проверить, был ли он добавлен ранее. Значение запроса — строка длины от 1 до 25, состоящая из больших и малых букв английского алфавита и цифр. Гарантируется, что запросов insert будет не более 600 000, при этом запросов contains с ответом «нет» хотя бы 10 000.

### Формат выходного файла

Выходной файл состоит из одной строки, содержащей ответы на все запросы contains в порядке их следования. Каждый из ответов представлен единственным символом, ’0’, если ответ «нет», или ’1’, если «да».

### Примеры

|входные данные|выходные данные|
|input.txt|output.txt|
|---|---|
|3|10|
|1 foo|
|0 foo|
|0 bar|

### Замечание

Данный пример заметно короче требуемого в условии (содержит менее 10 000 тестов с ответом «нет»). Он представлен исключительно для примера и является первым тестом для проверки ввода/вывода.